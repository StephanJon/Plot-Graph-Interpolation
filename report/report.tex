\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{listings}
\usepackage{booktabs}

\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

\title{Assignment 2 Report}
\author{Your Name and MACID}
\date{\today}

\begin {document}

\maketitle

Introductory blurb.

\section{Testing of the Original Program}

Each method for CurveADT.py, SeqService.py, and Data.py were tested individually while using assertions to check if the desired result was given after calling each method. Everything ran as expected.

\section{Results of Testing Partner's Code}

Testing the file without making any changes to the original test\_ALL.py results in errors because my partner named the variables for the x and y data a different name. In addition, my partner has interpretted the Data class to not be an ADT, and instead use static methods to change Data's variable S and Z. After making the appropriate changes to my test\_All.py and placing these changes in test\_All\_partner.py, all test cases passed except for index() under the class SeqServices.

\section{Discussion of Test Results}

\subsection{Problems with Original Code}
After seeing the partner codes, I have realized that I have misinterpreted the Data class specificataion and wrote the class as if it was an ADT. 

\subsection{Problems with Partner's Code}
The only thing wrong with my partner's code was the method index() under the class SeqServices. Upon inspection, index() returned one less than the desired index. For example, the index of 5 in list [1, 3, 5, 7] is two, but index() would return one.

\subsection{Problems with Assignment Specification}
The only problem with the assignment specifications was for the Data class. The constructor for the data class is assumed to initialize the parameters for an object of Data, rather than re-inizializing varibales of the class Data. Although one can interpret it correctly by realizing Data.py is not named DataADT.py like CurveADT.py, if someone does not read the specifications carefully enough, they can initially assume that Data.py holds code for an ADT. 

\section{Answers}

\begin{enumerate}

\item What is the mathematical specification of the \texttt{SeqServices} access
  program isInBounds(X, x) if the assumption that X is ascending is removed?


\item How would you modify \texttt{CurveADT.py} to support cubic interpolation?

First, the exported Constant MAX\_ORDER will be changed to 3. Second, interp(X, Y, o, v) will be modifiied with an added condition when o = 3. The added condition will run through a cubic interpolation formula when o = 3.


\item What is your critique of the CurveADT module's interface.  In particular,
  comment on whether the exported access programs provide an interface that is
  consistent, essential, general, minimal and opaque.

CurveADT's module's interface:\\
- is consistent because each method name corresponds to the behavior of each respective method.\\
- is essential because unnecessary access programs such as interp(X, Y, o, v) are omitted.\\
- is not general because each method is specific for lists of x and y data points that assumes the lists are ascending.\\
- is minimal because every method does exactly one thing; there are no methods that provide multiple services. \\
- is opaque because each method can only be accessed by an object of CurveT, and the data structure of an object of CurveT can only accessed by accessor methods in the CurveT class; this enforces information hiding.


\item What is your critique of the Data abstract object's interface.  In

Data's module's interface:\\
- is consistent because each method name corresponds to the behavior of each respective method\\
- is enssential because there are no unnecessary access programs to omit\\
- is not general because it is assumed that the lists under the Data class have equal length. (i.e. the method add() )\\
- is minimal because every method does exactly one thing; there are no methods that provide multiple services. \\
- is not opaque because every method can be accessed so long as the Data class has been imported. Every variable under the Data class such as S and Z is also easily accessed without any accessor methods. 

\end{enumerate}

\newpage

\lstset{language=Python, basicstyle=\tiny, breaklines=true, showspaces=false,
  showstringspaces=false, breakatwhitespace=true}

\def\thesection{\Alph{section}}

\section{Code for CurveADT.py}

\noindent \lstinputlisting{../src/CurveADT.py}

\newpage

\section{Code for Data.py}

\noindent \lstinputlisting{../src/Data.py}

\newpage

\section{Code for SeqServices.py}

\noindent \lstinputlisting{../src/SeqServices.py}

\newpage

\section{Code for Plot.py}

\noindent \lstinputlisting{../src/Plot.py}

\newpage

\section{Code for Load.py}

\noindent \lstinputlisting{../src/Load.py}

\newpage

\section{Code for Partner's CurveADT.py}

\noindent \lstinputlisting{../partner/CurveADT.py}

% Uncomment the line below when partner files have been pushed to your repo
%\noindent \lstinputlisting{../partner/CurveADT.py}

\newpage

\section{Code for Partner's Data.py}

\noindent \lstinputlisting{../partner/Data.py}

% Uncomment the line below when partner files have been pushed to your repo
%\noindent \lstinputlisting{../partner/Data.py}

\newpage

\section{Code for Partner's SeqServices.py}

\noindent \lstinputlisting{../partner/SeqServices.py}

% Uncomment the line below when partner files have been pushed to your repo
%\noindent \lstinputlisting{../partner/SeqServices.py}

\newpage

\section{Makefile}

\lstset{language=make}
\noindent \lstinputlisting{../Makefile}

\end {document}
